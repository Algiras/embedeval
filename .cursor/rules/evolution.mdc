---
description: Rules for implementing evolution and research features
globs: ["src/evolution/**/*.ts", "src/research/**/*.ts", "src/analysis/**/*.ts"]
alwaysApply: false
---

# Evolution System Rules

## Core Principle

The evolution system follows a biological metaphor:

- **Genome** = Strategy configuration
- **Fitness** = Evaluation metrics (NDCG, recall, etc.)
- **Population** = Set of candidate strategies
- **Generation** = One cycle of evaluation + selection + reproduction
- **Mutation** = Random changes to strategy parameters
- **Crossover** = Combining two parent strategies

## Genome Structure

When working with strategy genomes:

```typescript
interface StrategyGenome {
  id: string;  // UUID
  genes: {
    // Chunking genes
    chunkingMethod?: 'none' | 'fixed' | 'semantic' | 'sliding';
    chunkSize?: number;        // 128-1024
    chunkOverlap?: number;     // 0-50%
    
    // Retrieval genes
    retrievalMethod: 'cosine' | 'bm25' | 'hybrid';
    retrievalK: number;        // 10-100
    hybridWeights?: [number, number];  // [embedding, bm25]
    
    // Reranking genes
    rerankingMethod?: 'none' | 'llm' | 'mmr' | 'cross-encoder';
    rerankingTopK?: number;    // 5-20
    mmrLambda?: number;        // 0-1
  };
  
  // Metadata
  fitness?: number;
  generation: number;
  parents?: [string, string];
  mutations?: string[];
}
```

## Mutation Operators

Implement mutations carefully:

```typescript
function mutate(genome: StrategyGenome, rate: number): StrategyGenome {
  const mutated = { ...genome, id: uuidv4() };
  
  // Numeric mutations: Gaussian perturbation
  if (Math.random() < rate) {
    mutated.genes.chunkSize = clamp(
      genome.genes.chunkSize + gaussian(0, 64),
      128, 1024
    );
  }
  
  // Categorical mutations: Random selection
  if (Math.random() < rate) {
    mutated.genes.rerankingMethod = randomChoice([
      'none', 'llm', 'mmr', 'cross-encoder'
    ]);
  }
  
  return mutated;
}
```

## Selection Methods

Support multiple selection strategies:

```typescript
type SelectionMethod = 'tournament' | 'elitist' | 'roulette';

function select(
  population: StrategyGenome[],
  method: SelectionMethod,
  count: number
): StrategyGenome[] {
  switch (method) {
    case 'tournament':
      return tournamentSelection(population, count, tournamentSize: 3);
    case 'elitist':
      return population.slice(0, count);  // Assumes sorted by fitness
    case 'roulette':
      return rouletteWheelSelection(population, count);
  }
}
```

## Fitness Evaluation

Fitness is computed from evaluation metrics:

```typescript
interface FitnessConfig {
  primaryMetric: string;      // e.g., 'ndcg@10'
  weights?: Record<string, number>;
  constraints?: {
    maxLatency?: number;
    maxCost?: number;
  };
}

function computeFitness(
  results: EvaluationResult,
  config: FitnessConfig
): number {
  let fitness = results.metrics[config.primaryMetric];
  
  // Apply constraints as penalties
  if (config.constraints?.maxLatency) {
    if (results.latency > config.constraints.maxLatency) {
      fitness *= 0.5;  // 50% penalty
    }
  }
  
  return fitness;
}
```

## Knowledge Base Integration

Evolution should learn from history:

```typescript
class EvolutionEngine {
  constructor(private kb: KnowledgeBase) {}
  
  async evolve(): Promise<StrategyGenome> {
    // Use past learnings to seed population
    const seeds = await this.kb.getBestStrategies(5);
    
    // Run evolution
    const winner = await this.runEvolution(seeds);
    
    // Store learnings
    await this.kb.recordEvolution({
      generation: this.generation,
      winner,
      population: this.population,
    });
    
    return winner;
  }
}
```

## Auto-Deployment Rules

Be careful with auto-deployment:

1. **Require statistical significance** (p < 0.05)
2. **Require minimum improvement** (e.g., 3%)
3. **Run canary first** (10% traffic)
4. **Monitor for regressions** (24h window)
5. **Support instant rollback**

```typescript
interface DeploymentConfig {
  autoDeployEnabled: boolean;
  significanceThreshold: number;  // 0.05
  minImprovement: number;         // 0.03
  canaryPercentage: number;       // 0.1
  monitoringWindowHours: number;  // 24
}
```
